import yt_dlp
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import os
import tempfile
import uuid

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Configuration
DOWNLOAD_FOLDER = './downloads'
if not os.path.exists(DOWNLOAD_FOLDER):
    os.makedirs(DOWNLOAD_FOLDER)

@app.route('/api/info', methods=['POST'])
def get_video_info():
    try:
        data = request.json
        url = data.get('videoUrl')
        
        if not url:
            return jsonify({'error': 'No URL provided'}), 400
        
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            # Extract available formats
            formats = []
            for fmt in info.get('formats', []):
                if fmt.get('filesize') or fmt.get('filesize_approx'):
                    quality = fmt.get('format_note', 'Unknown')
                    if not quality or quality == 'unknown':
                        quality = f"{fmt.get('height', '')}p" if fmt.get('height') else 'Audio'
                    
                    resolution = f"{fmt.get('width', '')}x{fmt.get('height', '')}" if fmt.get('width') and fmt.get('height') else 'Audio'
                    
                    file_size = fmt.get('filesize') or fmt.get('filesize_approx')
                    if file_size:
                        size_mb = round(file_size / (1024 * 1024), 1)
                        size_str = f"{size_mb} MB"
                    else:
                        size_str = 'Unknown'
                    
                    formats.append({
                        'quality': quality,
                        'resolution': resolution,
                        'size': size_str,
                        'format': fmt.get('ext', 'mp4'),
                        'format_id': fmt.get('format_id')
                    })
            
            # Remove duplicates and sort by quality
            unique_formats = []
            seen = set()
            for fmt in formats:
                key = (fmt['quality'], fmt['resolution'])
                if key not in seen:
                    seen.add(key)
                    unique_formats.append(fmt)
            
            # Sort formats by quality (highest first)
            unique_formats.sort(key=lambda x: (
                0 if 'p' in x['quality'] else 1,
                int(x['quality'].replace('p', '')) if x['quality'].replace('p', '').isdigit() else 0
            ), reverse=True)
            
            return jsonify({
                'title': info.get('title', 'Unknown Title'),
                'channel': info.get('uploader', 'Unknown Channel'),
                'duration': info.get('duration_string', 'Unknown Duration'),
                'thumbnail': info.get('thumbnail', ''),
                'formats': unique_formats,
                'url': url
            })
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/download', methods=['POST'])
def download_video():
    try:
        data = request.json
        url = data.get('videoUrl')
        quality = data.get('quality')
        format_type = data.get('format', 'mp4')
        
        if not url:
            return jsonify({'error': 'No URL provided'}), 400
        
        # Generate unique filename
        file_id = str(uuid.uuid4())
        filename = f"{file_id}.{format_type}"
        filepath = os.path.join(DOWNLOAD_FOLDER, filename)
        
        # Configure yt-dlp options based on format
        if format_type == 'mp3':
            ydl_opts = {
                'format': 'bestaudio/best',
                'outtmpl': filepath.replace(f'.{format_type}', ''),
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
            }
        else:
            # For video downloads, try to get the specified quality
            ydl_opts = {
                'format': f'bestvideo[height<={quality[:-1]}][ext=mp4]+bestaudio[ext=m4a]/best[height<={quality[:-1]}]/best',
                'outtmpl': filepath,
                'merge_output_format': 'mp4',
            }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            ydl.download([url])
        
        # Check if file was created (handle different naming for audio)
        if format_type == 'mp3' and os.path.exists(filepath.replace(f'.{format_type}', '.mp3')):
            actual_filepath = filepath.replace(f'.{format_type}', '.mp3')
        else:
            actual_filepath = filepath
        
        if os.path.exists(actual_filepath):
            # In a production environment, you would upload to a cloud storage
            # and return a secure URL. For demo purposes, we return a local path.
            download_url = f"/api/files/{filename}"
            
            return jsonify({
                'status': 'success',
                'downloadUrl': download_url,
                'filename': filename
            })
        else:
            return jsonify({'error': 'File not found after download'}), 500
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/files/<filename>')
def serve_file(filename):
    try:
        filepath = os.path.join(DOWNLOAD_FOLDER, filename)
        
        # Handle MP3 files with different naming
        if not os.path.exists(filepath) and filepath.endswith('.mp4'):
            mp3_path = filepath.replace('.mp4', '.mp3')
            if os.path.exists(mp3_path):
                filepath = mp3_path
                filename = filename.replace('.mp4', '.mp3')
        
        if os.path.exists(filepath):
            return send_file(filepath, as_attachment=True, download_name=filename)
        else:
            return jsonify({'error': 'File not found'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, port=5000)
